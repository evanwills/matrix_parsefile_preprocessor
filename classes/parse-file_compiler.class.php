<?php

namespace matrix_parsefile_preprocessor;

require_once(dirname(__FILE__).'/parse-file_config.class.php');
require_once(dirname(__FILE__).'/parse-file_validator.class.php');
require_once(dirname(__FILE__).'/parse-file_nested-partials.class.php');

class compiler {

	private $config = null;

	private $validator = null;


	/**
	 * @var string absolute file path of the current
	 *		parse-file/partial being processed
	 */
	private $current_file = '';

	/**
	 * @var string full contents of the current parse-file/partial
	 *		being processed
	 */
	private $current_content = '';

	/**
	 * @var string $output_file name of file to be used as output of
	 *		compiled Squiz Matrix parse file XML
	 */
	private $output_file = '';

	/**
	 * @var resource $output file resource generated by fopen
	 */
	private $output = null;

	/**
	 * @var string last_match the complete string matched by the
	 * 		compiler regex to be used at the end of parsing this
	 *   	parse-file/partial
	 */
	private $last_match = '';

	private $fail_on_unprinted = false;
	private $show_error_extended = false;
	private $handle_comments = null;
	private $handle_white_space = null;
	private $handle_wrap = null;

	private $is_initialised = false;


	/**
	 * @const string INCLUDES_REGEX a regular expression for
	 * matching preparse file keywords
	 *		[0] the full match of the keyword string
	 *  	[1] whole keyword
	 *  	[2] preceeding content
	 *  	[3] opening wrapper
	 *		[4] the directory path to find the preparse
	 *			block or sub-preparse file (relative to the
	 *			current preparse file)
	 *		[5] the name of the file to be included
	 *  	[6] (optional) find/replace delimiter [`~|]
	 *		[7] (optional) find string/regex to do find and
	 *			replace on the praparse block/sub-preparse
	 *			file
	 *		[8] (optional) replace string to be used in
	 *			conjuction with find string/regex
	 *		[9] (optional) regex modifiers/regex identifier
	 *			"R" (if no modifiers)
	 *		[10] closing wrapper
	 */
	const INCLUDES_REGEX = '@
( # [1] preceeding content
	.*?
)
( # [2] whole keyword
	( # [3] opening wrapper
		[\{\}\[\]]{2}
	)
	(?:
		( # [4] path
			(?:[a-zA-Z0-9_-]+/)*
		)
		( # [5] file
			[a-zA-Z0-9_-]+
		)
		(?:
			( # [6] find/replace delimiter
				[\`\|\~\;]
			)
			( # [7] find string/pattern
				.*?
			)
			(?<!\\\\)
			\6
			( # [8] replace string/pattern
				.*?
			)
			(?:
				(?<!\\\\)
				\6
				( # [9] regex identifier/modifiers
					[RimsxeADSUXJu]{1,11}
				)
			)?
		)?
	)
	( # [10] closing wrapper
		[\{\}\[\]]{2}
	)
)
@x';

	/**
	 * @const string TRIM_LINE_REGEX for trimming lines from the
	 * beginning and end of a preparse file partial
	 */
	const TRIM_LINE_REGEX = '`(?:^(?:[\t ]*[\r\n]+)+|(?:[\r\n]+[\t ]*)+$)`';

	/**
	 * @const string COMMENT_REGEX checks with a preparse file
	 * partial has JS/CSS comments at the beginning of the file
	 */
	const COMMENT_REGEX = '^\s*/\*';

	const STRIP_COMMENT_REGEX = '`<!--(?!=\[).*?-->|/\*.*?\*/`s';

	const STRIP_WHITE_SPACE_COMPACT = '`(?<=^|[\r\n])[\t ]+|[\t ](?=[\r\n|$)`';




	public function __construct( $base_file )
	{
		$this->config = config::get($base_file);
		$this->nested_partials = nested_partials::get($base_file);
		$this->validator = new validator();

		$file_parts = pathinfo(realpath($base_file));

		$this->output_file = $this->config->get_var('output_dir').$file_parts['basename'];
		$this->output = fopen( $this->output_file , 'w+' );


		$ws = $this->config->get_var('white_space');
		if( $ws == 'normal' )
		{
			$this->handle_white_space = '_white_space_normal';
		}
		else
		{
			$this->handle_white_space = '_strip_white_space';
			if( $ws == 'compress' )
			{
				$this->white_space_regex = '`\s+`';
			}
			else
			{
				$this->white_space_regex = self::STRIP_WHITE_SPACE_COMPACT;
			}
		}

		if( $this->config->get_var('strip_comments') === true )
		{
			$this->handle_comments = '_strip_comments';
			$this->handle_wrap = '_dont_wrap';
		}
		else
		{
			$this->handle_comments = '_leave_comments';
			$this->handle_wrap = '_wrap_in_comments';
		}
	}

	public function __destruct()
	{
		fclose($this->output);
	}

	public function parse( $file_name )
	{
		if( !is_string($file_name) || trim($file_name) === '' )
		{
			throw new \exception(get_class($this).'::parse() expects only parameter $file_name to be a non-empty string. '.gettype($file_name).' given.');
		}

		if( substr(strtolower($file_name),-4,4) !== '.xml' )
		{
			$file_name .= '.xml';
		}
		$file_parts = pathinfo($file_name);
		$path = $this->nested_partials->add( $file_parts['dirname'].'/' , $file_parts['filename'] );

		$file = $path.$file_parts['basename'];
		debug(
			 '$file = '.$file
			,'$path = '.$path
			,'$file_name = '.$file_name
			,'$file_parts = '.print_r($file_parts,true)
		);
		if( file_exists($file) )
		{

			$content = file_get_contents($file);
			$this->current_file[] = $file;
			$this->current_content[] = $content;

			$matches = 0;

			// mixed preg_replace_callback ( mixed $pattern , callback $callback , mixed $subject [, int $limit = -1 [, int &$count ]] )
			$content = preg_replace_callback( self::INCLUDES_REGEX , [ $this , 'PARSE_KEYWORDS_CALLBACK' ] , $content , -1 , $matches );

			if( $matches < 1 )
			{
				$this->validator->parse( $content , $file );
				fwrite( $this->output , $content );
			}
			elseif( preg_match('`'.preg_quote($this->last_match).'(.*)$`s' , $content , $matches ) )
			{
				$this->validator->parse( $matches[1] , $file , $content );
				fwrite( $this->output , $matches[1] );
			}

			$this->nested_partials->remove();
			array_pop($this->current_file);
			array_pop($this->current_content);
		}
	}


	/**
	 * a pass through method to get errors from the validator
	 * @return array a list in order of all the tags that have
	 *               errors or warnings.
	 */
	public function get_errors()
	{
		return $this->validator->get_errors();
	}


	/**
	 * @function PARSE_KEYWORDS_CALLBACK() uses the match array of a
	 * regular expression on a single preparse file keyword and
	 * returns the defined contents after doing some stuff with it.
	 * @param  array $inc an array of seven items:
	 *		[0] the full match of the keyword string
	 *  	[1] whole keyword
	 *  	[2] preceeding content
	 *  	[3] opening wrapper
	 *		[4] the directory path to find the preparse
	 *			block or sub-preparse file (relative to the
	 *			current preparse file)
	 *		[5] the name of the file to be included
	 *  	[6] (optional) find/replace delimiter [`~|]
	 *		[7] (optional) find string/regex to do find and
	 *			replace on the praparse block/sub-preparse
	 *			file
	 *		[8] (optional) replace string to be used in
	 *			conjuction with find string/regex
	 *		[9] (optional) regex modifiers/regex identifier
	 *			"R" (if no modifiers)
	 *		[10] closing wrapper
	 */
	private function PARSE_KEYWORDS_CALLBACK($matches)
	{
		$this->validator->parse( $matches[1] , $this->current_file , $this->current_content );
		$this->last_match = $matches[0];


		$ok = false;
		$no_comments = false;
		if( $matches[3] == '{{' && $matches[10] == '}}' ) {
			$ok = true;
		} elseif( $matches[3] == '{[' && $matches[10] == ']}'  ) {
			$ok = true;
			$no_comments = true;
		} else {
			// keyword dlimiters
			$this->_display_error($matches[2], "Keyword delimiters '{$matches[3]}' and '{$matches[10]}' are not valid");
		}


	}




	/**
	 * @function _get_error_line() returns the line the current
	 * keyword is on in the preparse file being processed
	 * @param  string $pattern (equivelent to $inc[0]) the full
	 *                keyword string where an error has occured
	 * @return integer the line number of the current keyword
	 */
	private function _get_error_line($pattern) {
		$arr =	preg_split(
						 '`(\r\n|\n\r|\r|\n)`'
						,preg_replace(
							 '`(?<='.preg_quote($pattern).').*$`s'
							,''
							,$this->current_content
						)
				);
		return count($arr);
	}


	private function _dont_wrap($partial_content,$keyword)
	{
		return $this->_strip_comments($partial_content);
	}

	private function _wrap_in_comments($partial_content,$keyword)
	{
		$open = '<!--';
		$close = '-->';
		if( preg_match( '`^\s*/\*`' , $partial_content ) )
		{
			$open = '/*';
			$close = '*/';
		}
		$open = "\n$open|| ";
		$close = "||$close\n";

		return "{$open}START: $keyword {$close}{$partial_content}{$open} END:  $keyword $close";
	}

	private function _strip_comments($partial_content)
	{
		return preg_replace( '`<!--(?!=\[).*?-->|/\*.*?\*/`s' , '' , $partial_content );
	}

	private function _leave_comments($partial_content)
	{
		return $partial_content;
	}

	private function _white_space_normal($input) {
		return $input;
	}

	private function _strip_white_space($input) {
		$pre = $erp = [];
		preg_match_all('`<pre[^>]*>.*?</pre>`is',$input,$matches);
		for( $a = 0 ; $a > $matches[0] ; $a += 1 )
		{
			$pre[] = $matches[$a];
			$erp[] = '<<{PRE'.$a.'}>>';
		}
		return str_replace(
				$erp,
				$pre,
				preg_replace(
					$this->white_space_regex,
					' ' ,
					str_replace(
						$pre,
						$erp,
						$input
					)
				)
			);
	}
}